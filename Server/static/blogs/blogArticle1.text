<ol>
	                                <li>/*&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;如果我们要查找的集合本身没有顺序，在频繁查找的同时还经常插入和删除，构建一棵二叉树比较合适。&nbsp;</li>
	                                <li>&nbsp;*/&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;</li>
	                                <li>//&nbsp;&nbsp;定义节点&nbsp;&nbsp;</li>
	                                <li>function&nbsp;Node(data,left,right,parent){&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;this.data=data;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;结点存放的值&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;this.parent=parent;&nbsp;//&nbsp;父结点&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;this.left=left;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;左子结点&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;this.right=right;&nbsp;&nbsp;&nbsp;//&nbsp;右子结点&nbsp;&nbsp;</li>
	                                <li>}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;</li>
	                                <li>//&nbsp;&nbsp;定义二叉排序树（BST）类&nbsp;&nbsp;</li>
	                                <li>function&nbsp;BST()&nbsp;{&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;this.root=null;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;根结点&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;this.insert=insert;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;插入&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;this.insert2AVL=insert2AVL;&nbsp;//&nbsp;插入，并调整为平衡二叉树&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;this.remove=remove;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;remove和cutoff都是删除一个结点，实现方法不同&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;this.cutoff=cutoff;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;this.preOrderTraverse=preOrderTraverse;&nbsp;//&nbsp;前序遍历&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;this.inOrderTraverse=inOrderTraverse;&nbsp;&nbsp;&nbsp;//&nbsp;中序遍历，结果是升序的&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;this.postOrderTraverse=preOrderTraverse;//&nbsp;后序遍历&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;this.getMin=getMin;&nbsp;//&nbsp;查找最小值&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;this.getMax=getMax;&nbsp;//&nbsp;查找最大值&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;this.find=find;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;查找指定值&nbsp;&nbsp;</li>
	                                <li>}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;</li>
	                                <li>/*&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;插入&nbsp;</li>
	                                <li>&nbsp;</li>
	                                <li>&nbsp;*/&nbsp;&nbsp;</li>
	                                <li>function&nbsp;insert(data)&nbsp;{&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;node=new&nbsp;Node(data,null,null,null);&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;if(this.root===null){&nbsp;&nbsp;&nbsp;//&nbsp;如果是一棵空树，直接&nbsp;this.root=node&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.root=node;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;//&nbsp;如果不是空树&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;cur=this.root;&nbsp;//&nbsp;定义一个遍历指针，指向当前node，初始值为根节点&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;parent;&nbsp;//&nbsp;定义一个指针，指向当前node的父节点&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(true){&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent=cur;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(data===cur.data){&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果插入的值已经存在，则终止插入&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(data&lt;cur.data){&nbsp;&nbsp;//如果插入的值小于当前节点的值，遍历指针指向其left&nbsp;node&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cur=cur.left;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!cur){&nbsp;&nbsp;&nbsp;//&nbsp;如果left&nbsp;node不存在，则此处（parent.left）就是目标位置。&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent.left=node;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.parent=parent;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cur=cur.right;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!cur){&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent.right=node;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.parent=parent;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	                                <li>}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;</li>
	                                <li>/*&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;插入，并调整为平衡二叉树&nbsp;</li>
	                                <li>&nbsp;</li>
	                                <li>&nbsp;*/&nbsp;&nbsp;</li>
	                                <li>function&nbsp;insert2AVL()&nbsp;{&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;</li>
	                                <li>}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;</li>
	                                <li>/*&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;遍历。&nbsp;</li>
	                                <li>&nbsp;</li>
	                                <li>&nbsp;*/&nbsp;&nbsp;</li>
	                                <li>//中序遍历，结果以数组形式返回&nbsp;&nbsp;</li>
	                                <li>function&nbsp;inOrderTraverse()&nbsp;{&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;arr=[];&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;inOrder(this.root,arr);&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;arr;&nbsp;&nbsp;</li>
	                                <li>}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;</li>
	                                <li>function&nbsp;inOrder(BST,arr)&nbsp;{&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;if(BST){&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inOrder(BST.left,arr);&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr.push(BST.data);&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inOrder(BST.right,arr);&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	                                <li>}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;</li>
	                                <li>//前遍历，结果以数组形式返回&nbsp;&nbsp;</li>
	                                <li>function&nbsp;preOrderTraverse()&nbsp;{&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;arr=[];&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;preOrder(this.root,arr);&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;arr;&nbsp;&nbsp;</li>
	                                <li>}&nbsp;&nbsp;</li>
	                                <li>function&nbsp;preOrder(BST,arr)&nbsp;{&nbsp;//将BST前序输出到arr数组里&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;if(BST){&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr.push(BST.data);&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preOrder(BST.left,arr);&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preOrder(BST.right,arr);&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	                                <li>}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;</li>
	                                <li>//后序遍历，结果以数组形式返回&nbsp;&nbsp;</li>
	                                <li>function&nbsp;postOrderTraverse()&nbsp;{&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;arr=[];&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;postOrder(this.root,arr);&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;arr;&nbsp;&nbsp;</li>
	                                <li>}&nbsp;&nbsp;</li>
	                                <li>function&nbsp;postOrder(BST,arr)&nbsp;{&nbsp;//将BST后序输出到arr数组里&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;if(BST){&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;postOrder(BST.left,arr);&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;postOrder(BST.right,arr);&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr.push(BST.data);&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	                                <li>}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;</li>
	                                <li>/*&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;查找（最大值、最小值、特定值）&nbsp;</li>
	                                <li>&nbsp;</li>
	                                <li>&nbsp;*/&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;</li>
	                                <li>function&nbsp;getMin()&nbsp;{&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;cur=this.root;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(cur.left){&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cur=cur.left;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;cur.data;&nbsp;&nbsp;</li>
	                                <li>}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;</li>
	                                <li>function&nbsp;getMax()&nbsp;{&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;cur=this.root;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(cur.right){&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cur=cur.right;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;cur.data;&nbsp;&nbsp;</li>
	                                <li>}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;</li>
	                                <li>function&nbsp;find(item)&nbsp;{&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;cur=this.root;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(cur){&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(cur.data===item){return&nbsp;true;}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(cur.data&gt;item){cur=cur.left;}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{cur=cur.right;}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;&nbsp;&nbsp;</li>
	                                <li>}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;</li>
	                                <li>/*&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;删除方法1：不需要知道父结点&nbsp;</li>
	                                <li>&nbsp;</li>
	                                <li>&nbsp;*/&nbsp;&nbsp;</li>
	                                <li>function&nbsp;remove(data)&nbsp;{&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;removeNode(this.root,&nbsp;data);&nbsp;&nbsp;</li>
	                                <li>}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;</li>
	                                <li>function&nbsp;removeNode(node,&nbsp;data)&nbsp;{&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(node&nbsp;===&nbsp;null)&nbsp;{&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(data&nbsp;===&nbsp;node.data)&nbsp;{&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;没有子节点的节点&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(node.left&nbsp;===&nbsp;null&nbsp;&amp;&amp;&nbsp;node.right&nbsp;===&nbsp;null)&nbsp;{&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;没有左子节点的节点&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(node.left&nbsp;===&nbsp;null)&nbsp;{&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;node.right;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;没有右子节点的节点&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(node.right&nbsp;===&nbsp;null)&nbsp;{&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;node.left;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;有两个子节点的节点,用删除结点的直接后继代替&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;tempNode=node.right;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(tempNode.left){&nbsp;//&nbsp;找到直接后继结点,也就是右子树的最小结点&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tempNode=tempNode.left;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.data&nbsp;=&nbsp;tempNode.data;&nbsp;&nbsp;//&nbsp;将直接后继节点的值&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.right&nbsp;=&nbsp;removeNode(node.right,&nbsp;tempNode.data);&nbsp;//&nbsp;node的右子树等于去除直接后继结点后的子树&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;node;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;if&nbsp;(data&nbsp;&lt;&nbsp;node.data)&nbsp;{&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.left&nbsp;=&nbsp;removeNode(node.left,&nbsp;data);&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;node;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.right&nbsp;=&nbsp;removeNode(node.right,&nbsp;data);&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;node;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	                                <li>}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;</li>
	                                <li>/*&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;删除方法2：结点需要知道父结点&nbsp;</li>
	                                <li>&nbsp;</li>
	                                <li>&nbsp;*/&nbsp;&nbsp;</li>
	                                <li>function&nbsp;cutoff(data)&nbsp;{&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;cut(this.root,data);&nbsp;&nbsp;</li>
	                                <li>}&nbsp;&nbsp;</li>
	                                <li>function&nbsp;cut(BST,item)&nbsp;{&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;if(!BST){return&nbsp;false;}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;else{&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(item===BST.data){&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;cutNode(BST);&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else&nbsp;if(item&lt;BST.data){&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;cut(BST.left,item);&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;cut(BST.right,item);&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	                                <li>}&nbsp;&nbsp;</li>
	                                <li>//&nbsp;从二叉排序树中删除结点node,并重接它的左或右子树&nbsp;&nbsp;</li>
	                                <li>function&nbsp;cutNode(node)&nbsp;{&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;q,s;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;if(node.left===null&amp;&amp;node.right===null){&nbsp;//&nbsp;删除节点为叶子结点，直接设置为null，浏览器在空闲时垃圾回收&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(node===node.parent.left){node.parent.left=null;}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(node===node.parent.right){node.parent.right=null;}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;}else&nbsp;if(node.left===null){&nbsp;//&nbsp;删除结点只有右子树&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*q=node;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node=node.right;&nbsp;//&nbsp;原结点并没有改变&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q=null;*/&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;注意！&nbsp;必能通过直接修改node来达到目的，要通过修改node里面的内容。&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q=node.right;&nbsp;//&nbsp;先把node的右子树保存下来&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.data=q.data;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.left=q.left;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.right=q.right;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q=null;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;}else&nbsp;if(node.right===null){&nbsp;//&nbsp;删除结点只有左子树&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q=node.left;&nbsp;//&nbsp;先把node的左子树保存下来&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.data=q.data;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.left=q.left;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.right=q.right;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q=null;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;&nbsp;//&nbsp;删除结点左右子树都有&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q=node;&nbsp;s=node.left;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(s.right){&nbsp;//&nbsp;转左，再向右找到尽头（待删结点的前驱s）&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q=s;&nbsp;s=s.right;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.data=s.data;&nbsp;//&nbsp;将直接前驱的值赋给待删结点&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(q!==node){&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q.right=s.left;&nbsp;//&nbsp;重接q的右子树&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q.left=s.left;&nbsp;//&nbsp;重接q的左子树&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s=null;&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;&nbsp;&nbsp;</li>
	                                <li>}&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;</li>
	                                <li>var&nbsp;arr=[62,88,58,47,35,73,51,99,37,93];&nbsp;&nbsp;</li>
	                                <li>var&nbsp;bst=new&nbsp;BST();&nbsp;&nbsp;</li>
	                                <li>arr.forEach(function&nbsp;(item)&nbsp;{&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;&nbsp;&nbsp;bst.insert(item);&nbsp;&nbsp;</li>
	                                <li>});&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;</li>
	                                <li>console.log(bst.preOrderTraverse());&nbsp;//[&nbsp;62,&nbsp;58,&nbsp;47,&nbsp;35,&nbsp;37,&nbsp;51,&nbsp;88,&nbsp;73,&nbsp;99,&nbsp;93&nbsp;]&nbsp;&nbsp;</li>
	                                <li>console.log(bst.inOrderTraverse());&nbsp;//[&nbsp;35,&nbsp;37,&nbsp;47,&nbsp;51,&nbsp;58,&nbsp;62,&nbsp;73,&nbsp;88,&nbsp;93,&nbsp;99&nbsp;]&nbsp;&nbsp;</li>
	                                <li>console.log(bst.postOrderTraverse());&nbsp;//[&nbsp;62,&nbsp;58,&nbsp;47,&nbsp;35,&nbsp;37,&nbsp;51,&nbsp;88,&nbsp;73,&nbsp;99,&nbsp;93&nbsp;]&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;</li>
	                                <li>console.log(bst.getMin());&nbsp;//35&nbsp;&nbsp;</li>
	                                <li>console.log(bst.getMax());&nbsp;//99&nbsp;&nbsp;</li>
	                                <li>console.log(bst.find(62));&nbsp;//true&nbsp;&nbsp;</li>
	                                <li>&nbsp;&nbsp;</li>
	                                <li>bst.remove(62);&nbsp;&nbsp;</li>
	                                <li>console.log(bst.inOrderTraverse());&nbsp;//[&nbsp;35,&nbsp;37,&nbsp;47,&nbsp;51,&nbsp;58,&nbsp;73,&nbsp;88,&nbsp;93,&nbsp;99&nbsp;]&nbsp;&nbsp;</li>
	                                <li>bst.cutoff(58);&nbsp;&nbsp;</li>
	                                <li>console.log(bst.inOrderTraverse());&nbsp;//[&nbsp;35,&nbsp;37,&nbsp;47,&nbsp;51,&nbsp;73,&nbsp;88,&nbsp;93,&nbsp;99&nbsp;]&nbsp;</li>
                                </ol>